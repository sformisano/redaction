//! Application layer: Redaction machinery.
//!
//! This module provides the infrastructure for applying redaction:
//!
//! - [`RedactionMapper`]: Internal trait for mapping values during traversal
//! - [`Classifiable`]: Types that can have classifications applied recursively
//! - [`redact`]: The entry point function for redacting a value
//! - [`ScalarRedaction`]: Helper trait for scalar default values
//!
//! ## How Classifiable Works
//!
//! For a field like:
//! ```ignore
//! #[sensitive(Pii)]
//! addresses: Option<Vec<String>>
//! ```
//!
//! The generated code calls:
//! ```ignore
//! Classifiable::apply_classification::<Pii, _>(addresses, mapper)
//! ```
//!
//! At runtime, this recursively descends:
//! 1. `Option<Vec<String>>` → calls `.map(|v| v.apply_classification::<Pii, _>(mapper))`
//! 2. `Vec<String>` → calls `.into_iter().map(|v| v.apply_classification::<Pii, _>(mapper)).collect()`
//! 3. `String` → calls `mapper.map_sensitive::<_, Pii>(self)`
//!
//! The recursion handles any nesting depth automatically!

use std::{
    borrow::Cow,
    collections::{BTreeMap, BTreeSet, HashMap, HashSet},
    hash::{BuildHasher, Hash},
};

use super::{
    policy::RedactionPolicy,
    sensitive::{SensitiveType, SensitiveValue},
};

// =============================================================================
// RedactionMapper - Internal mapping trait
// =============================================================================

/// Maps sensitive and non-sensitive values during traversal.
///
/// This is the internal machinery that applies redaction policies.
/// Implementations must return the same value type for `map_sensitive`.
#[doc(hidden)]
pub trait RedactionMapper {
    /// Maps a sensitive, string-like value.
    fn map_sensitive<V, P>(&self, value: V) -> V
    where
        V: SensitiveValue,
        P: RedactionPolicy;

    /// Maps a sensitive scalar value to its default.
    ///
    /// Scalars are marked with bare `#[sensitive]` and cannot use classifications.
    fn map_scalar<S>(&self, value: S) -> S
    where
        S: Default + ScalarRedaction;
}

/// The default mapper that applies redaction policies.
#[derive(Clone, Copy, Debug)]
struct PolicyMapper;

impl RedactionMapper for PolicyMapper {
    fn map_sensitive<V, P>(&self, value: V) -> V
    where
        V: SensitiveValue,
        P: RedactionPolicy,
    {
        let policy = P::policy();
        let redacted = policy.apply_to(value.as_str());
        V::from_redacted(redacted)
    }

    fn map_scalar<S>(&self, value: S) -> S
    where
        S: Default + ScalarRedaction,
    {
        // Special case: char defaults to '\0' which isn't useful, so use 'X' instead
        // We use a helper trait to handle this cleanly
        ScalarRedaction::redact(value)
    }
}

// =============================================================================
// ScalarRedaction - Helper for scalar defaults
// =============================================================================

/// Helper trait to handle scalar redaction, with special cases.
#[doc(hidden)]
pub trait ScalarRedaction: Default {
    #[must_use]
    fn redact(self) -> Self {
        Self::default()
    }
}

impl ScalarRedaction for i8 {}
impl ScalarRedaction for i16 {}
impl ScalarRedaction for i32 {}
impl ScalarRedaction for i64 {}
impl ScalarRedaction for i128 {}
impl ScalarRedaction for isize {}
impl ScalarRedaction for u8 {}
impl ScalarRedaction for u16 {}
impl ScalarRedaction for u32 {}
impl ScalarRedaction for u64 {}
impl ScalarRedaction for u128 {}
impl ScalarRedaction for usize {}
impl ScalarRedaction for f32 {}
impl ScalarRedaction for f64 {}
impl ScalarRedaction for bool {}

impl ScalarRedaction for char {
    fn redact(self) -> Self {
        'X'
    }
}

// =============================================================================
// redact() - Entry point function
// =============================================================================

/// Redacts a value using classification-bound policies.
///
/// The traversal is defined by [`SensitiveType`] implementations, typically
/// generated by the derive macro.
///
/// This function is total: policy application does not propagate errors. Any
/// failure handling is performed by the selected policy implementation.
pub fn redact<W>(value: W) -> W
where
    W: SensitiveType,
{
    let mapper = PolicyMapper;
    value.redact_with(&mapper)
}

// =============================================================================
// Classifiable - Recursive classification application
// =============================================================================

/// A type that can have a classification policy applied recursively to its inner values.
///
/// This trait enables `#[sensitive(Classification)]` to work on nested wrapper types
/// like `Option<Vec<String>>` by recursively delegating through each wrapper layer
/// until reaching a leaf type that implements [`SensitiveValue`].
///
/// ## Implementors
///
/// - **Wrapper types** (`Option`, `Vec`, `Box`, maps, sets): Recursively apply to contents
/// - **Leaf types** (`String`, `Cow<str>`): Apply the classification policy directly
///
/// ## Example
///
/// ```ignore
/// #[derive(Clone, Sensitive)]
/// struct User {
///     #[sensitive(Pii)]
///     emails: Option<Vec<String>>,  // Works! Recursively applies Pii to each String
/// }
/// ```
#[diagnostic::on_unimplemented(
    message = "`{Self}` cannot have a classification applied",
    label = "this type doesn't support classification policies",
    note = "classifications work on String, Cow<str>, and containers of these types",
    note = "for custom string-like types, implement `SensitiveValue`"
)]
#[doc(hidden)]
pub trait Classifiable {
    /// Applies a classification policy through the type structure.
    ///
    /// For wrapper types, this recursively applies to inner values.
    /// For leaf types, this applies the policy directly.
    #[must_use]
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper;
}

// =============================================================================
// Classifiable: Base case implementations (leaf types)
// =============================================================================

impl Classifiable for String {
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        mapper.map_sensitive::<_, C>(self)
    }
}

impl Classifiable for Cow<'_, str> {
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        mapper.map_sensitive::<_, C>(self)
    }
}

// =============================================================================
// Classifiable: Recursive implementations (wrapper types)
// =============================================================================

impl<T: Classifiable> Classifiable for Option<T> {
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        self.map(|v| v.apply_classification::<C, M>(mapper))
    }
}

impl<T: Classifiable> Classifiable for Vec<T> {
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        self.into_iter()
            .map(|v| v.apply_classification::<C, M>(mapper))
            .collect()
    }
}

impl<T: Classifiable> Classifiable for Box<T> {
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        Box::new((*self).apply_classification::<C, M>(mapper))
    }
}

impl<T, E> Classifiable for Result<T, E>
where
    T: Classifiable,
    E: Classifiable,
{
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        match self {
            Ok(v) => Ok(v.apply_classification::<C, M>(mapper)),
            Err(e) => Err(e.apply_classification::<C, M>(mapper)),
        }
    }
}

// Maps: apply classification to values only (keys unchanged)
impl<K, V, S> Classifiable for HashMap<K, V, S>
where
    K: Hash + Eq,
    V: Classifiable,
    S: BuildHasher + Clone,
{
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        let hasher = self.hasher().clone();
        let mut result = HashMap::with_hasher(hasher);
        result.extend(
            self.into_iter()
                .map(|(k, v)| (k, v.apply_classification::<C, M>(mapper))),
        );
        result
    }
}

impl<K, V> Classifiable for BTreeMap<K, V>
where
    K: Ord,
    V: Classifiable,
{
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        self.into_iter()
            .map(|(k, v)| (k, v.apply_classification::<C, M>(mapper)))
            .collect()
    }
}

// Sets: apply classification to elements
impl<T, S> Classifiable for HashSet<T, S>
where
    T: Classifiable + Hash + Eq,
    S: BuildHasher + Clone,
{
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        let hasher = self.hasher().clone();
        let mut result = HashSet::with_hasher(hasher);
        result.extend(
            self.into_iter()
                .map(|v| v.apply_classification::<C, M>(mapper)),
        );
        result
    }
}

impl<T> Classifiable for BTreeSet<T>
where
    T: Classifiable + Ord,
{
    fn apply_classification<C, M>(self, mapper: &M) -> Self
    where
        C: RedactionPolicy,
        M: RedactionMapper,
    {
        self.into_iter()
            .map(|v| v.apply_classification::<C, M>(mapper))
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use std::collections::HashMap;

    use super::redact;
    use crate::{Secret, Sensitive};

    #[test]
    fn redact_applies_classification_policy() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct SecretValue {
            #[sensitive(Secret)]
            value: String,
        }

        let value = SecretValue {
            value: "top_secret".to_string(),
        };
        let redacted = redact(value);
        assert_eq!(redacted.value, "[REDACTED]");
    }

    #[test]
    fn apply_classification_to_string() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct Simple {
            #[sensitive(Secret)]
            value: String,
        }

        let s = Simple {
            value: "secret".into(),
        };
        let redacted = redact(s);
        assert_eq!(redacted.value, "[REDACTED]");
    }

    #[test]
    fn apply_classification_to_option_string() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct WithOption {
            #[sensitive(Secret)]
            value: Option<String>,
        }

        let s = WithOption {
            value: Some("secret".into()),
        };
        let redacted = redact(s);
        assert_eq!(redacted.value, Some("[REDACTED]".into()));
    }

    #[test]
    fn apply_classification_to_vec_string() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct WithVec {
            #[sensitive(Secret)]
            values: Vec<String>,
        }

        let s = WithVec {
            values: vec!["secret1".into(), "secret2".into()],
        };
        let redacted = redact(s);
        assert_eq!(redacted.values, vec!["[REDACTED]", "[REDACTED]"]);
    }

    #[test]
    fn apply_classification_to_nested_option_vec() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct Nested {
            #[sensitive(Secret)]
            values: Option<Vec<String>>,
        }

        let s = Nested {
            values: Some(vec!["secret1".into(), "secret2".into()]),
        };
        let redacted = redact(s);
        assert_eq!(
            redacted.values,
            Some(vec!["[REDACTED]".into(), "[REDACTED]".into()])
        );
    }

    #[test]
    fn apply_classification_to_nested_vec_option() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct Nested {
            #[sensitive(Secret)]
            values: Vec<Option<String>>,
        }

        let s = Nested {
            values: vec![Some("secret1".into()), None, Some("secret2".into())],
        };
        let redacted = redact(s);
        assert_eq!(
            redacted.values,
            vec![Some("[REDACTED]".into()), None, Some("[REDACTED]".into())]
        );
    }

    #[test]
    fn apply_classification_to_deeply_nested() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct DeepNest {
            #[sensitive(Secret)]
            values: Option<Vec<Option<String>>>,
        }

        let s = DeepNest {
            values: Some(vec![Some("secret".into()), None]),
        };
        let redacted = redact(s);
        assert_eq!(redacted.values, Some(vec![Some("[REDACTED]".into()), None]));
    }

    #[test]
    fn apply_classification_to_hashmap_values() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct WithMap {
            #[sensitive(Secret)]
            data: HashMap<String, String>,
        }

        let mut data = HashMap::new();
        data.insert("key1".into(), "secret1".into());
        data.insert("key2".into(), "secret2".into());

        let s = WithMap { data };
        let redacted = redact(s);

        // Keys preserved, values redacted
        assert!(redacted.data.contains_key("key1"));
        assert!(redacted.data.contains_key("key2"));
        assert_eq!(redacted.data.get("key1"), Some(&"[REDACTED]".to_string()));
        assert_eq!(redacted.data.get("key2"), Some(&"[REDACTED]".to_string()));
    }

    #[test]
    fn apply_classification_to_nested_map_vec() {
        #[derive(Clone, Sensitive)]
        #[cfg_attr(feature = "slog", derive(serde::Serialize))]
        struct ComplexNest {
            #[sensitive(Secret)]
            data: HashMap<String, Vec<String>>,
        }

        let mut data = HashMap::new();
        data.insert("emails".into(), vec!["a@b.com".into(), "c@d.com".into()]);

        let s = ComplexNest { data };
        let redacted = redact(s);

        assert_eq!(
            redacted.data.get("emails"),
            Some(&vec!["[REDACTED]".to_string(), "[REDACTED]".to_string()])
        );
    }
}
